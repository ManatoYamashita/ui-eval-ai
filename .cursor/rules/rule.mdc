---
description: 
globs: 
alwaysApply: true
---
# AI Design Feedback App - Cursor Development Rules

## Project Overview
You are developing an AI-powered design feedback web application that analyzes uploaded images and provides professional UI/UX improvement suggestions based on authoritative design guidelines (WCAG, Apple HIG, Refactoring UI).

## Architecture & Tech Stack
- **Frontend**: Next.js 15 (App Router), TypeScript, TailwindCSS
- **Database**: Supabase (PostgreSQL + pgvector)
- **AI Services**: Claude 3.5 Haiku (image analysis), OpenAI Embeddings (text vectorization)
- **Search**: Hybrid search (vector + full-text search)
- **Deployment**: Vercel (frontend), Supabase Cloud (database)

## Project Structure
```
design-feedback-app/
├── app/
│   ├── api/
│   │   ├── analyze/route.ts          # Main analysis API
│   │   ├── search/route.ts           # Guidelines search API
│   │   └── embed/route.ts            # Text embedding API
│   ├── components/
│   │   └── ui/
│   │       ├── FileUpload.tsx        # File upload component
│   │       ├── AnalysisResult.tsx    # Analysis results display
│   │       └── LoadingSpinner.tsx    # Loading states
│   ├── lib/
│   │   ├── supabase.ts              # Supabase client
│   │   ├── ai-clients.ts            # AI API clients
│   │   ├── ai-analysis.ts           # Image analysis logic
│   │   ├── rag-search.ts            # RAG search logic
│   │   └── utils.ts                 # Utility functions
│   ├── types/
│   │   ├── analysis.ts              # Analysis types
│   │   ├── guidelines.ts            # Guidelines types
│   │   └── api.ts                   # API types
│   └── page.tsx                     # Main page
└── scripts/
    └── setup-knowledge-base.ts      # Knowledge base setup
```

## Core System Design

### RAG Analysis Pipeline
1. **Image preprocessing**: Resize, optimize quality
2. **Element identification**: Auto-detect UI elements using AI
3. **Dynamic RAG search**: Search relevant guidelines based on detected elements
4. **Structured prompt generation**: Create comprehensive analysis prompts
5. **AI analysis**: Generate improvement suggestions with code examples

### Database Schema (Supabase)
```sql
CREATE TABLE design_guidelines (
  id BIGSERIAL PRIMARY KEY,
  content TEXT NOT NULL,
  source VARCHAR(100) NOT NULL,     -- WCAG, Apple HIG, Refactoring UI
  category VARCHAR(50) NOT NULL,    -- accessibility, usability, visual_design
  subcategory VARCHAR(100),         -- color_contrast, touch_targets, typography
  embedding VECTOR(1536),           -- OpenAI embeddings
  metadata JSONB,
  keywords TEXT[],
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

## TypeScript Standards

### Strict Type Safety
- Use strict TypeScript settings
- No `any` types allowed
- All functions must have explicit return types
- Use branded types for IDs and sensitive data

### Interface Definitions
```typescript
interface AnalysisRequest {
  image: File;
  prompt: string;
}

interface AnalysisResponse {
  success: boolean;
  analysis: {
    current_issues: string;
    improvements: ImprovementSuggestion[];
    predicted_impact: PredictedImpact;
  };
  guidelines_used: GuidelineReference[];
  processing_time: number;
}

interface ImprovementSuggestion {
  priority: 'high' | 'medium' | 'low';
  title: string;
  problem: string;
  solution: string;
  implementation: string;  // TailwindCSS code example
  guideline_reference: string;
}
```

## Coding Standards

### Component Structure
- Use functional components with hooks
- Implement proper error boundaries
- Include loading states for all async operations
- Use Suspense for data fetching where appropriate

### API Route Structure
```typescript
export async function POST(request: NextRequest) {
  try {
    // 1. Validate input
    // 2. Process request
    // 3. Return structured response
  } catch (error) {
    console.error('API Error:', error);
    return Response.json(
      { error: 'Descriptive error message' },
      { status: appropriateStatusCode }
    );
  }
}
```

### Error Handling
- All async functions must have try-catch blocks
- Return user-friendly error messages
- Log detailed errors for debugging
- Use proper HTTP status codes

## AI Integration Guidelines

### Claude API Integration
```typescript
const analysisPrompt = `
あなたはUI/UXデザインの専門家です。以下の画像を分析してください：

【分析観点】
1. アクセシビリティ (WCAG準拠)
2. ユーザビリティ (操作性・情報設計)
3. 視覚デザイン (階層・色彩・レイアウト)

【出力形式】
## 🔍 現状分析
## 💡 改善提案（優先度順）
### 🔴 高優先度
### 🟡 中優先度
### 🟢 低優先度
## 💻 実装例 (TailwindCSS)
## 📊 改善効果予測

各提案には根拠となるガイドラインを明記してください。
`;
```

### OpenAI Embeddings
- Use text-embedding-ada-002 model
- Implement proper retry logic for API failures
- Cache embeddings when possible

### RAG Search Implementation
```typescript
// Hybrid search: 70% vector similarity + 30% text ranking
const { data } = await supabase.rpc('hybrid_search', {
  query_text: searchQuery,
  query_embedding: embedding,
  match_threshold: 0.7,
  match_count: 5
});
```

## UI/UX Standards

### TailwindCSS Usage
- Use utility-first approach
- Create custom components for repeated patterns
- Implement responsive design mobile-first
- Use semantic color names in tailwind.config.js

### Accessibility Requirements
- All interactive elements must have proper ARIA labels
- Minimum touch target size: 44px × 44px
- Color contrast ratio: 4.5:1 for normal text, 3:1 for large text
- Keyboard navigation support required

### Loading States
```typescript
{isAnalyzing ? (
  <div className="flex items-center justify-center">
    <LoadingSpinner />
    <span className="ml-2">分析中...</span>
  </div>
) : (
  'デザインを分析する'
)}
```

## Performance Requirements

### File Upload Optimization
- Maximum file size: 10MB
- Supported formats: JPEG, PNG, GIF
- Client-side image compression before upload
- Progress indicators for uploads

### API Response Time
- Analysis completion: < 10 seconds
- Search queries: < 2 seconds
- Database queries: < 500ms

### Caching Strategy
- Cache embeddings in memory during session
- Use Supabase query caching for guidelines
- Implement request deduplication

## Security Guidelines

### File Upload Security
```typescript
// Validate file type and size
const allowedTypes = ['image/jpeg', 'image/png', 'image/gif'];
const maxSize = 10 * 1024 * 1024; // 10MB

if (!allowedTypes.includes(file.type)) {
  throw new Error('Unsupported file type');
}
if (file.size > maxSize) {
  throw new Error('File too large');
}
```

### API Security
- Rate limiting: 100 requests per hour per IP
- Input sanitization for all user inputs
- Proper CORS configuration
- Environment variables for all secrets

### Data Privacy
- No persistent storage of uploaded images
- Clear user data after analysis completion
- Implement proper error messages without exposing system details

## Database Operations

### Supabase Client Usage
```typescript
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY! // Use service role for admin operations
);
```

### Query Optimization
- Use appropriate indexes for search operations
- Implement query result pagination for large datasets
- Use database functions for complex operations

## Testing Requirements

### Unit Testing
- Test all utility functions
- Mock external API calls
- Test error handling paths

### Integration Testing
- Test complete analysis pipeline
- Verify database operations
- Test file upload functionality

## Development Workflow

### Code Quality
- Use ESLint and Prettier for consistent formatting
- Run TypeScript strict mode checks
- Implement proper logging for debugging

### Environment Setup
```bash
# Required environment variables
NEXT_PUBLIC_SUPABASE_URL=
NEXT_PUBLIC_SUPABASE_ANON_KEY=
SUPABASE_SERVICE_ROLE_KEY=
ANTHROPIC_API_KEY=
OPENAI_API_KEY=
```

## Implementation Priorities

### Phase 1: Core Infrastructure
1. Next.js project setup with TypeScript
2. Basic file upload component
3. Supabase database schema
4. Environment configuration

### Phase 2: RAG System
1. Knowledge base setup script
2. Hybrid search function implementation
3. Embedding generation system
4. Search API endpoints

### Phase 3: AI Analysis
1. Image preprocessing pipeline
2. Element identification system
3. Prompt engineering for Claude API
4. Analysis result processing

### Phase 4: UI Polish
1. Result display components
2. Loading and error states
3. Responsive design implementation
4. Accessibility improvements

## Common Patterns

### Async Function Template
```typescript
async function processAnalysis(
  image: File, 
  prompt: string
): Promise<AnalysisResult> {
  try {
    // Validate inputs
    validateInputs(image, prompt);
    
    // Process
    const result = await performAnalysis(image, prompt);
    
    // Return structured result
    return {
      success: true,
      data: result,
      timestamp: new Date().toISOString()
    };
  } catch (error) {
    console.error('Analysis failed:', error);
    throw new AnalysisError('Analysis processing failed', error);
  }
}
```

### Error Boundary Component
```typescript
'use client';

export default function ErrorBoundary({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  return (
    <div className="text-center p-8">
      <h2 className="text-lg font-semibold text-red-600">
        エラーが発生しました
      </h2>
      <button
        onClick={reset}
        className="mt-4 px-4 py-2 bg-blue-600 text-white rounded"
      >
        再試行
      </button>
    </div>
  );
}
```

## Documentation Standards

### Code Comments
- Use JSDoc for all public functions
- Comment complex business logic
- Include usage examples for utility functions

### README Requirements
- Clear setup instructions
- API documentation
- Environment variable descriptions
- Deployment guidelines

## Quality Checklist

Before committing code, ensure:
- [ ] TypeScript compilation passes without errors
- [ ] All tests pass
- [ ] ESLint passes without warnings
- [ ] Components are properly typed
- [ ] Error handling is implemented
- [ ] Loading states are included
- [ ] Accessibility requirements are met
- [ ] Performance benchmarks are met

## Documentation Management

### Master Reference Document
- **ALWAYS** reference `/app/docs/dev.md` before implementing any features
- This file contains the complete project specification and implementation guidelines
- If you encounter any conflicts between these rules and dev.md, prioritize dev.md

### Documentation Update Requirements
When implementing features or discovering new insights:

1. **Check dev.md first**: Verify current specifications and implementation patterns
2. **Update dev.md**: If implementation reveals new patterns, optimizations, or corrections
3. **Create new docs**: Add specialized documentation in `/app/docs/` when needed

### Documentation Structure in `/app/docs/`
```
/app/docs/
├── dev.md                    # Master development reference (MAIN SOURCE OF TRUTH)
├── api.md                    # API documentation and examples
├── database.md               # Database schema and migration guides
├── deployment.md             # Deployment and environment setup
├── troubleshooting.md        # Common issues and solutions
├── performance.md            # Performance optimization guides
└── security.md               # Security guidelines and best practices
```

### When to Create New Documentation
Create new documentation files when:
- **API complexity**: Endpoints require detailed examples or complex workflows
- **Database operations**: Complex queries, migrations, or schema changes
- **Performance insights**: Optimization discoveries or benchmarking results
- **Security findings**: New security considerations or implementation patterns
- **Troubleshooting**: Recurring issues or complex debugging procedures
- **Deployment specifics**: Environment-specific configurations or procedures

### Documentation Update Process
```typescript
// Example: When implementing a new feature
1. Read /app/docs/dev.md to understand current specifications
2. Implement the feature following the guidelines
3. If you discover improvements or clarifications:
   - Update relevant sections in dev.md
   - Add detailed examples to specialized docs if needed
   - Document any deviations from original plan with reasoning

// Example update format for dev.md:
/*
## 📝 Implementation Updates

### [Date] - [Feature/Change]
**What changed**: [Description]
**Why**: [Reasoning]
**Impact**: [Effect on other parts]
**New patterns**: [Any new best practices discovered]
*/
```

### Documentation Standards
- Use clear, actionable language
- Include code examples for complex concepts
- Update timestamps for significant changes
- Maintain backward compatibility notes
- Cross-reference related sections

## Development Workflow with Documentation

### Before Starting Implementation
1. **Read dev.md**: Understand the feature requirements and current specifications
2. **Check specialized docs**: Review relevant API, database, or security documentation
3. **Plan implementation**: Ensure alignment with documented patterns

### During Implementation
1. **Follow dev.md guidelines**: Use established patterns and standards
2. **Document deviations**: If you need to deviate from the plan, document why
3. **Note improvements**: Keep track of optimizations or better approaches discovered

### After Implementation
1. **Update dev.md**: Add any new insights, patterns, or corrections
2. **Create specialized docs**: If the feature requires detailed documentation
3. **Update troubleshooting**: Add any issues encountered and their solutions

### Documentation Review Checklist
Before completing any feature:
- [ ] dev.md is updated with any new patterns or changes
- [ ] Specialized documentation is created if complexity warrants it
- [ ] Code examples in documentation are tested and accurate
- [ ] Cross-references between documents are updated
- [ ] Implementation aligns with documented specifications

## Development Notes

When implementing features:
1. **Always check `/app/docs/dev.md` first** - it's the source of truth
2. Start with type definitions as specified in dev.md
3. Implement error handling following documented patterns
4. Add loading states for all async operations
5. Test with real data scenarios
6. Consider edge cases and error conditions
7. Implement proper logging for debugging
8. Follow the established patterns consistently
9. **Update documentation** if you discover better approaches
10. **Create new docs** if the feature complexity requires it

Remember: This is a production-ready application that needs to handle real user data securely and efficiently while providing professional-quality design analysis. All implementations must be properly documented for future maintainability.